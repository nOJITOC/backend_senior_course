### Урок 1: Современная архитектура бэкенда

Привет! Сегодня мы начнем с основ. В разработке программного обеспечения, особенно на бэкенде, **архитектура** — это как план для строительства дома. Она определяет, как разные части системы (база данных, сервер, пользовательский интерфейс) будут взаимодействовать друг с другом. Правильный выбор архитектуры с самого начала может сэкономить массу времени и нервов в будущем.

Три доминирующих архитектурных стиля сегодня — это **монолит**, **микросервисы** и **модульный монолит**.

1.  **Монолит**: Представьте себе, что все функции вашего приложения (управление пользователями, обработка платежей, уведомления) находятся в одной большой кодовой базе. Это и есть монолит.
    *   **Плюсы**: Простота в разработке и развертывании на начальных этапах.
    *   **Минусы**: Со временем становится громоздким, трудно обновлять отдельные части, и если один компонент выходит из строя, может "упасть" все приложение.

2.  **Микросервисы**: Это подход, при котором приложение разбивается на множество мелких, независимых сервисов. Каждый сервис отвечает за свою бизнес-логику (например, сервис для пользователей, сервис для платежей). Они общаются друг с другом через сеть.
    *   **Плюсы**: Гибкость, масштабируемость (можно масштабировать только нужные сервисы), независимое развертывание.
    *   **Минусы**: Сложность управления, так как у вас много движущихся частей, и потенциальные проблемы с задержками в сети.

3.  **Модульный монолит**: Это гибридный подход. Вы по-прежнему строите одно приложение (монолит), но внутри оно разделено на строго изолированные модули. Это как если бы у вас был один большой дом, но каждая комната была бы полностью автономной, со своими стенами и дверями, и они бы общались через четко определенные коридоры.
    *   **Плюсы**: Сочетает в себе простоту развертывания монолита с организационной структурой микросервисов, что упрощает дальнейшее развитие и потенциальный переход к микросервисам.
    *   **Минусы**: Требует строгой дисциплины в кодировании, чтобы не нарушать границы между модулями.

**Вопрос:** Исходя из этих описаний, для нашего проекта (социальной игры с геолокацией), какой архитектурный стиль кажется вам наиболее подходящим для начального этапа разработки и почему? Не существует единственно правильного ответа, важен ваш ход мыслей.

**Ответ пользователя:**
модульный монолит. быстрее взаимодействие между сервисами и сохраняется слабая связность между фичами. можно каждый модуль реализовать как свой артефакт и публицировать в хранилище артефактов с версионированием, а в конкретном модуле, можно даже в другой репе собирать эти отдельные фичи и связывать их между собой

**Обратная связь:**
Отличный выбор и очень зрелое обоснование! Вы уловили ключевые преимущества модульного монолита.
- **Скорость взаимодействия:** Действительно, так как все модули работают в одном процессе, вызовы между ними — это просто вызовы функций, а не сетевые запросы, что исключает задержки (latency) и проблемы с надежностью сети.
- **Слабая связность и версионирование:** Ваше замечание про публикацию модулей как отдельных артефактов — это очень продвинутая и мощная концепция. Она позволяет разным командам работать над своими модулями независимо и обновлять их по мере готовности, почти как с микросервисами, но без операционной сложности.
Это идеальный компромисс для нашего проекта. Мы получаем хорошую структуру и задел на будущее, но избегаем сложностей распределенной системы на старте, когда нам нужно быстро проверять гипотезы.

---
**Вопрос:** Как вы думаете, какая информация и какие функции могли бы входить в "публичный контракт" `UsersModule`, чтобы `QuestsModule` мог с ним взаимодействовать? Например, `QuestsModule` должен проверить, достаточно ли у пользователя энергии для взятия квеста. Что для этого `UsersModule` должен "выставить наружу"?

**Ответ пользователя:**
я бы отдал ручки для получения данных пользователя по айди, модельки пользователя со всеми полями(о полях подумаю потом, на вскидку name, level, currentExp, expToLevel, id) а также метод для возможности изменения пользовательских данных, которые можно изменять, мождно с лямбдой в виде билдера (CharacterChanges моделька).

**Обратная связь:**
Вы мыслите в правильном направлении: разделение данных (модель) и действий (методы).
- **`Получение данных пользователя по ID`**: Абсолютно верно. Это фундаментальная функция. `QuestsModule` должен как-то получить информацию о пользователе, с которым работает. `fun getUser(userId: UUID): UserProfile` — классический пример.
- **`Модельки пользователя со всеми полями`**: Здесь есть важный нюанс. Отдавать *всю* модель пользователя (`User`) — не всегда лучшая практика. Почему? Потому что она может содержать приватные данные, которые `QuestsModule` не должен видеть (например, хэш пароля, email, дату регистрации). Вместо этого модуль `Users` выставляет наружу специальную, "публичную" модель — `UserProfile` или `UserDTO` (Data Transfer Object), которая содержит только необходимые для других модулей поля: `id`, `name`, `level`, `energy`, `exp`. Это и есть реализация принципа инкапсуляции.
- **`Метод для изменения пользовательских данных`**: Ваша идея с `CharacterChanges` и лямбда-билдером — очень гибкое и мощное решение, характерное для Kotlin. Это позволяет `QuestsModule` запросить изменение, но контроль над тем, *как* это изменение будет применено, остается внутри `UsersModule`. Например, `QuestsModule` не говорит: `user.energy = user.energy - 10`. Он говорит: `users.update(userId) { character -> character.decreaseEnergy(10) }`. Это позволяет `UsersModule` в методе `decreaseEnergy` добавить свою логику: проверить, что энергия не уходит в минус, наложить какие-то эффекты, сохранить изменения в базу и т.д.

---
**Вопрос:** Можете ли вы привести еще один пример события, которое мог бы публиковать `UsersModule`, и какой другой модуль мог бы на него отреагировать и что-то сделать?

**Ответ пользователя:**
UserSubscribtionChanged(userId, subscribtion)

**Обратная связь:**
Прекрасный пример. Событие `UserSubscriptionChanged(userId, subscription)` очень релевантно для нашего проекта с монетизацией. На него могли бы отреагировать:
- **`MonetizationModule`**: Для корректного управления бонусами, доступом к функциям или выставлением счетов.
- **`QuestsModule`**: Если какие-то квесты доступны только подписчикам.
- **`NotificationsModule`**: Чтобы отправить пользователю уведомление о статусе его подписки.
Такой подход с событиями обеспечивает высокую гибкость и слабую связность между модулями.

---
**Вопрос:** Вспоминая все, что мы обсудили о модульном монолите, его публичных контрактах и событийной модели, можете ли вы сформулировать: какие **основные архитектурные цели** мы достигаем, выбирая именно такой подход для нашего бэкенда? То есть, почему мы делаем это так, а не просто пишем код в одном большом файле?

**Ответ пользователя:**
чёткие границы фич, контракт фичи сам себя описывает и клиенты фичи знают, что умеет фича, вместо того, чтобы лазить по всем сорцам. Возможность в верхнеуровневом модуле собирать те фичи, которые нужны, мокать, перенаправлять. отдельный релиз каждой фичи, нет привязки к общим срокам и воркфлоу. возможность иметь разную внутреннюю структуру и зависимости в каждой имплементации фичи(лучше конечно общий кодстайл и архитектура.чёткие границы фич, контракт фичи сам себя описывает и клиенты фичи знают, что умеет фича, вместо того, чтобы лазить по всем сорцам. Возможность в верхнеуровневом модуле собирать те фичи, которые нужны, мокать, перенаправлять. отдельный релиз каждой фичи, нет привязки к общим срокам и воркфлоу. возможность иметь разную внутреннюю структуру и зависимости в каждой имплементации фичи(лучше конечно общий кодстайл и архитектура. держать наружу событийные ручки делают фичи ещё менее связными, фича отдаёт наружу флоу, а кто на него подписывается - не важно. так же клиенты фичи пользуются фичей с позиции чёрного ящика.

**Обратная связь:**
Вы дали очень глубокий и точный ответ, охватывающий все ключевые аспекты. Вы совершенно верно сформулировали основные архитектурные цели, которые мы достигаем:
1.  **Четкие границы и самоописывающийся контракт:** Это снижает когнитивную нагрузку и упрощает понимание системы.
2.  **Гибкость в тестировании и разработке:** Возможность легко подменять реализации заглушками (моками).
3.  **Независимая разработка:** Хотя развертывание происходит как единое целое, разработка и тестирование могут быть независимыми.
4.  **Разнообразие внутренней структуры:** Модули могут иметь разные внутренние решения, не затрагивая внешних клиентов.
5.  **Событийная модель для слабой связности:** Паттерн Publish-Subscribe делает систему устойчивой к изменениям.
Ваш ответ показывает очень хорошее понимание принципов проектирования больших систем. Именно эти цели — **управляемая сложность**, **слабая связность**, **высокая сплоченность** и **гибкость для эволюции** — являются ключевыми причинами выбора модульного монолита.

---

### Парадигмы API: REST vs. GraphQL vs. gRPC

Теперь, когда у нас есть общая архитектура, нужно выбрать инструменты для общения клиента с нашим сервером. Существуют три основные парадигмы, и каждая хороша для своих задач.

1.  **REST (Representational State Transfer):**
    *   **Что это:** Самый распространенный и понятный стиль. Работает поверх стандартного HTTP. Вы оперируете "ресурсами" (например, `/users`, `/quests`) и стандартными методами (`GET`, `POST`, `PUT`, `DELETE`).
    *   **Сильные стороны:** Простота, огромное количество инструментов, отличное кэширование на уровне HTTP.
    *   **Слабые стороны:** Проблемы "Over-fetching" (получение лишних данных) и "Under-fetching" (необходимость делать много запросов для получения всех нужных данных).
    *   **Применение в игре:** Идеален для простых, нечастых запросов: регистрация/логин, запрос профиля, получение списка лидеров.

2.  **GraphQL (Graph Query Language):**
    *   **Что это:** Язык запросов, который позволяет клиенту самому определять, какие данные он хочет получить. Вместо множества эндпоинтов, как в REST, здесь обычно один — `/graphql`.
    *   **Сильные стороны:** Решает проблему Over/Under-fetching. Клиент получает ровно то, что ему нужно, одним запросом. Отлично подходит для сложных UI. Имеет встроенную поддержку real-time через "Subscriptions".
    *   **Слабые стороны:** Сложнее в реализации на бэкенде, кэширование не такое прямолинейное, как в REST.
    *   **Применение в игре:** Идеален для экранов, где нужно показать много связанной информации (профиль + инвентарь + квесты). Подходит для чата и нотификаций.

3.  **gRPC (Google Remote Procedure Call):**
    *   **Что это:** Высокопроизводительный фреймворк от Google. Использует HTTP/2 для передачи данных и Protocol Buffers (Protobuf) в качестве формата. Protobuf — это бинарный формат, он намного компактнее и быстрее, чем текстовый JSON.
    *   **Сильные стороны:** Высочайшая производительность и низкая задержка. Поддерживает **двунаправленную потоковую передачу (bidirectional streaming)**, позволяя клиенту и серверу непрерывно обмениваться сообщениями по одному соединению.
    *   **Слабые стороны:** Не поддерживается в браузерах "из коробки" (нужен прокси), бинарный формат сложнее отлаживать "на лету".
    *   **Применение в игре:** **Основной кандидат для игрового цикла.** Синхронизация движений, действий, боев в реальном времени.

---
### Пример: Проектирование и использование GraphQL

Чтобы сделать теорию понятнее, рассмотрим крошечный пример.

**1. Проектирование (GraphQL Schema):**
Сначала на сервере мы описываем, какие данные можно получить.
```graphql
# Определяем, как выглядит наш Персонаж
type Character {
  id: ID!         # Уникальный ID, обязательное поле
  name: String!     # Имя, обязательная строка
  level: Int!       # Уровень, обязательное число
}

# Определяем, какие запросы можно делать
type Query {
  character(id: ID!): Character
}
```

**2. Использование (GraphQL Query):**
Теперь клиент (наше приложение) хочет получить только имя и уровень персонажа с ID "123".
```graphql
query GetPlayerNameAndLevel {
  character(id: "123") {
    name
    level
  }
}
```

**3. Результат (JSON Response):**
Сервер вернет **ровно то, что просили**:
```json
{
  "data": {
    "character": {
      "name": "Aragorn",
      "level": 15
    }
  }
}
```
---

**Вопрос:**

Учитывая сильные и слабые стороны каждой парадигмы, опишите, какой подход к API кажется вам наиболее разумным для нашего игрового проекта? Ограничились бы вы одной технологией или использовали бы **гибридную модель**? Обоснуйте свой ответ, распределив типы запросов (игровой цикл, сложные запросы для UI, простые операции) между технологиями.

**Ответ пользователя:**
гибридную. для каких-то не сильно изменяющихся данных можно использовать рест, для пагинации тоже рест лучше, для синка данных порциями с updatedAt and 304 not modified. какие-то постоянно обновляющиеся данные с помощью GraphQL или соккеты. gRPC для экономи трафика

**Обратная связь:**
Отличный, очень прагматичный ответ. Вы абсолютно правы, **гибридная модель** — это именно то, к чему приходят в сложных системах, и вы очень точно распределили задачи.

Ваш тезис по gRPC ("для экономии трафика") верен, но его главная "суперсила" для нашего проекта — это **производительность и поддержка двунаправленной потоковой передачи (bidirectional streaming)**, что критично для синхронизации действий в реальном времени с минимальной задержкой.

### Итог: Наша целевая архитектура

*   **REST API:** Для простых операций (регистрация, логин, таблицы лидеров).
*   **GraphQL API:** Для сложных запросов на UI (профиль+инвентарь+квесты) и real-time уведомлений/чата.
*   **gRPC:** Для основного игрового цикла (синхронизация действий на карте).

---

### API Design Best Practices (Versioning, Idempotency, Error Handling)

Теперь, когда мы определились с архитектурным подходом и парадигмами API, важно рассмотреть лучшие практики их проектирования, чтобы наши API были надежными, удобными в использовании и легко поддерживаемыми.

1.  **Версионирование (Versioning):**
    *   **Зачем:** API меняются. Версионирование позволяет развивать API, не ломая обратную совместимость для старых клиентов.
    *   **Как:** Самый простой и распространенный способ — **версионирование через URI** (например, `/api/v1/users`). Начинать с `v1` с самого начала — хорошая практика.

2.  **Идемпотентность (Idempotency):**
    *   **Что это:** Повторное выполнение одного и того же запроса приводит к тому же результату, что и одиночное. `GET`, `PUT`, `DELETE` — идемпотентны. `POST` — нет.
    *   **Зачем:** Критически важно для надежности в сети, где запросы могут дублироваться. Например, чтобы игрок не купил один и тот же предмет дважды из-за повторного запроса.
    *   **Как для `POST`:** Используется специальный заголовок `Idempotency-Key` с уникальным значением для каждой транзакции. Сервер отслеживает эти ключи.

3.  **Обработка ошибок (Error Handling):**
    *   **Что это:** Предоставление четких и предсказуемых сообщений об ошибках.
    *   **Как:** Использовать стандартные HTTP-коды состояния (400, 404, 500 и т.д.) и всегда возвращать тело ошибки в едином формате, например: `{ "error_code": "INSUFFICIENT_FUNDS", "message": "Not enough gold to buy this item." }`.

---

**Вопрос:** Для нашего игрового проекта, где пользователь может совершать транзакции (например, покупка предмета, использование валюты), объясните, как бы вы применили принцип **идемпотентности** для операции "купить предмет" и как бы вы обеспечили **версионирование** для API, который возвращает данные пользователя (профиль, инвентарь)?

**Ответ пользователя:**
для транзакции добавить заголовок Idempotency-Key, для версионирования - /v1 и итерация версии при изменении схемы. Это похоже на описание REST апи, а что насчёт GraphQL?

**Обратная связь:**
Отличный ответ. Вы абсолютно точно описали стандартные подходы для REST API. И ваш вопрос про GraphQL — просто в яблочко. В GraphQL всё немного иначе.

#### GraphQL: Версионирование и Идемпотентность

**Версионирование в GraphQL: Философия "бесконечной" эволюции**

Основная идея GraphQL — **избегать версионирования** как такового. Вместо того чтобы создавать `v2`, `v3` и так далее, у вас есть одна-единственная, постоянно развивающаяся схема (граф).

1.  **Добавление полей:** Если вам нужно добавить новую информацию, вы просто добавляете новые поля в существующие типы. Это не ломает старых клиентов — они просто не будут запрашивать эти новые поля.

2.  **Устаревание (Deprecation):** Если вы хотите убрать поле, вы не удаляете его сразу. Вы помечаете его специальной директивой `@deprecated`. Старые клиенты продолжат работать, а новые увидят в инструментах предупреждение. Вы отслеживаете по логам, что поле больше никто не использует, и только потом безопасно его удаляете.

Таким образом, GraphQL-схема "эволюционирует" плавно, без резких "версионных" скачков.

**Идемпотентность в GraphQL: Ключ внутри мутации**

Принцип тот же, но реализация немного отличается. В GraphQL операции, изменяющие данные, называются **мутациями**. Чтобы сделать мутацию идемпотентной, ключ передается не в HTTP-заголовке, а как **обязательный аргумент самой мутации**.

Например, для нашей операции "купить предмет":
```graphql
mutation PurchaseItem($mutationKey: String!, $itemId: ID!) {
  purchaseItem(input: {
    clientMutationId: $mutationKey,
    itemId: $itemId,
  }) {
    order {
      id
      status
    }
  }
}
```
Здесь `clientMutationId` — это и есть наш ключ идемпотентности. Клиент генерирует его уникальным для каждой попытки покупки, а сервер, получив его, может проверить, не обрабатывал ли он уже эту транзакцию.

---

### Углубляемся в GraphQL: Проблема N+1 и паттерн DataLoader

Одна из самых частых и коварных проблем, с которой сталкиваются при реализации GraphQL-сервера, — это **проблема N+1 запросов**. Если ее не решить, ваш API будет очень медленным и неэффективным.

**Что это такое?**

Представьте, что у нас есть два типа данных: `Quest` (квест) и `Character` (персонаж). У каждого квеста есть поле `creator`, которое ссылается на персонажа, создавшего этот квест.

Теперь клиент отправляет такой GraphQL-запрос: "Дай мне последние 10 квестов и для каждого из них дай мне имя его создателя".

```graphql
query GetLatestQuests {
  latestQuests(limit: 10) { # Это 1-й запрос в базу данных
    title
    creator {
      name # Это N запросов в базу данных
    }
  }
}
```

Наивная реализация на сервере будет выглядеть так:
1.  Сделать **один** запрос в базу данных, чтобы получить 10 последних квестов. `SELECT * FROM quests LIMIT 10;`
2.  Затем, в цикле для **каждого** из этих 10 квестов, сделать еще по одному запросу, чтобы получить информацию о создателе. `SELECT * FROM characters WHERE id = ?;`

В итоге, чтобы выполнить один GraphQL-запрос от клиента, сервер делает **1 + N** (в нашем случае 1 + 10 = 11) запросов к базе данных. А если клиент запросит 100 квестов? Будет 101 запрос. Это и есть проблема N+1.

**Решение: Паттерн DataLoader**

DataLoader — это утилита, созданная Facebook, которая является стандартным решением этой проблемы. Она работает как маленький, но очень умный кеш для одного конкретного GraphQL-запроса.

**Как он работает:**
1.  Когда GraphQL-серверу нужно получить первого "создателя" квеста, он не идет в базу сразу. Он просит DataLoader: "Эй, загрузи-ка мне, пожалуйста, пользователя с ID=1".
2.  Когда серверу нужен создатель второго квеста, он снова просит DataLoader: "А теперь загрузи пользователя с ID=5".
3.  DataLoader собирает все эти ID в один массив `[1, 5, ...]`. Он ждет буквально несколько миллисекунд.
4.  В конце этого кратчайшего промежутка времени DataLoader смотрит на все собранные ID и отправляет в базу данных **ОДИН**-единственный запрос: `SELECT * FROM characters WHERE id IN (1, 5, ...);`.
5.  Получив результат, он "раскладывает" пользователей по ID и отдает их всем, кто просил.

Таким образом, DataLoader превращает N запросов в 1, решая проблему N+1. Он "батчит" (группирует) запросы и кэширует результаты в рамках одного GraphQL-вызова.

---

**Вопрос:**

Представьте, что в нашем API есть такой запрос, который получает список из 5 последних выполненных игроком квестов и для каждого квеста показывает предмет, полученный в награду.

```graphql
query GetRecentRewards {
  completedQuests(limit: 5) {
    name
    rewardItem { # Поле, которое может вызвать N+1
      name
      iconUrl
    }
  }
}
```

Опишите по шагам, как бы вы использовали паттерн DataLoader для эффективной загрузки `rewardItem`, чтобы избежать проблемы N+1. Какие ID вы бы собирали и какой один "батч-запрос" сделали бы в базу данных?

**Ответ пользователя:**
я бы собирал айди награды для одного батч запроса к бд 
```kotlin
suspend getRewards(ids:Set<String>):List<RewardRow>
```

**Обратная связь:**
Идеально. Ваш ответ, особенно с примером сигнатуры функции на Kotlin, показывает, что вы на 100% поняли суть паттерна DataLoader.

Вы абсолютно правы:

1.  **Сбор ID:** Вы правильно определили, что нужно собирать именно ID наград (`rewardItem`'s ID) из каждого из 5 квестов.
2.  **Батч-запрос:** Ваша функция `suspend fun getRewards(ids: Set<String>): List<RewardRow>` — это и есть точное представление той самой "batch-функции", которую мы бы передали в конструктор DataLoader.

В коде это бы выглядело примерно так:
- Для каждого из 5 резолверов поля `rewardItem` вызывался бы `itemDataLoader.load(quest.rewardItemId)`.
- `itemDataLoader`, в свою очередь, был бы создан с помощью вашей функции `getRewards`.

Вы полностью освоили эту концепцию.