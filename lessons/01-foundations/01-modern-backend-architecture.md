### Урок 1: Современная архитектура бэкенда

Привет! Сегодня мы начнем с основ. В разработке программного обеспечения, особенно на бэкенде, **архитектура** — это как план для строительства дома. Она определяет, как разные части системы (база данных, сервер, пользовательский интерфейс) будут взаимодействовать друг с другом. Правильный выбор архитектуры с самого начала может сэкономить массу времени и нервов в будущем.

Три доминирующих архитектурных стиля сегодня — это **монолит**, **микросервисы** и **модульный монолит**.

1.  **Монолит**: Представьте себе, что все функции вашего приложения (управление пользователями, обработка платежей, уведомления) находятся в одной большой кодовой базе. Это и есть монолит.
    *   **Плюсы**: Простота в разработке и развертывании на начальных этапах.
    *   **Минусы**: Со временем становится громоздким, трудно обновлять отдельные части, и если один компонент выходит из строя, может "упасть" все приложение.

2.  **Микросервисы**: Это подход, при котором приложение разбивается на множество мелких, независимых сервисов. Каждый сервис отвечает за свою бизнес-логику (например, сервис для пользователей, сервис для платежей). Они общаются друг с другом через сеть.
    *   **Плюсы**: Гибкость, масштабируемость (можно масштабировать только нужные сервисы), независимое развертывание.
    *   **Минусы**: Сложность управления, так как у вас много движущихся частей, и потенциальные проблемы с задержками в сети.

3.  **Модульный монолит**: Это гибридный подход. Вы по-прежнему строите одно приложение (монолит), но внутри оно разделено на строго изолированные модули. Это как если бы у вас был один большой дом, но каждая комната была бы полностью автономной, со своими стенами и дверями, и они бы общались через четко определенные коридоры.
    *   **Плюсы**: Сочетает в себе простоту развертывания монолита с организационной структурой микросервисов, что упрощает дальнейшее развитие и потенциальный переход к микросервисам.
    *   **Минусы**: Требует строгой дисциплины в кодировании, чтобы не нарушать границы между модулями.

**Вопрос:** Исходя из этих описаний, для нашего проекта (социальной игры с геолокацией), какой архитектурный стиль кажется вам наиболее подходящим для начального этапа разработки и почему? Не существует единственно правильного ответа, важен ваш ход мыслей.

**Ответ пользователя:**
модульный монолит. быстрее взаимодействие между сервисами и сохраняется слабая связность между фичами. можно каждый модуль реализовать как свой артефакт и публицировать в хранилище артефактов с версионированием, а в конкретном модуле, можно даже в другой репе собирать эти отдельные фичи и связывать их между собой

**Обратная связь:**
Отличный выбор и очень зрелое обоснование! Вы уловили ключевые преимущества модульного монолита.
- **Скорость взаимодействия:** Действительно, так как все модули работают в одном процессе, вызовы между ними — это просто вызовы функций, а не сетевые запросы, что исключает задержки (latency) и проблемы с надежностью сети.
- **Слабая связность и версионирование:** Ваше замечание про публикацию модулей как отдельных артефактов — это очень продвинутая и мощная концепция. Она позволяет разным командам работать над своими модулями независимо и обновлять их по мере готовности, почти как с микросервисами, но без операционной сложности.
Это идеальный компромисс для нашего проекта. Мы получаем хорошую структуру и задел на будущее, но избегаем сложностей распределенной системы на старте, когда нам нужно быстро проверять гипотезы.

---
**Вопрос:** Как вы думаете, какая информация и какие функции могли бы входить в "публичный контракт" `UsersModule`, чтобы `QuestsModule` мог с ним взаимодействовать? Например, `QuestsModule` должен проверить, достаточно ли у пользователя энергии для взятия квеста. Что для этого `UsersModule` должен "выставить наружу"?

**Ответ пользователя:**
я бы отдал ручки для получения данных пользователя по айди, модельки пользователя со всеми полями(о полях подумаю потом, на вскидку name, level, currentExp, expToLevel, id) а также метод для возможности изменения пользовательских данных, которые можно изменять, мождно с лямбдой в виде билдера (CharacterChanges моделька).

**Обратная связь:**
Вы мыслите в правильном направлении: разделение данных (модель) и действий (методы).
- **`Получение данных пользователя по ID`**: Абсолютно верно. Это фундаментальная функция. `QuestsModule` должен как-то получить информацию о пользователе, с которым работает. `fun getUser(userId: UUID): UserProfile` — классический пример.
- **`Модельки пользователя со всеми полями`**: Здесь есть важный нюанс. Отдавать *всю* модель пользователя (`User`) — не всегда лучшая практика. Почему? Потому что она может содержать приватные данные, которые `QuestsModule` не должен видеть (например, хэш пароля, email, дату регистрации). Вместо этого модуль `Users` выставляет наружу специальную, "публичную" модель — `UserProfile` или `UserDTO` (Data Transfer Object), которая содержит только необходимые для других модулей поля: `id`, `name`, `level`, `energy`, `exp`. Это и есть реализация принципа инкапсуляции.
- **`Метод для изменения пользовательских данных`**: Ваша идея с `CharacterChanges` и лямбда-билдером — очень гибкое и мощное решение, характерное для Kotlin. Это позволяет `QuestsModule` запросить изменение, но контроль над тем, *как* это изменение будет применено, остается внутри `UsersModule`. Например, `QuestsModule` не говорит: `user.energy = user.energy - 10`. Он говорит: `users.update(userId) { character -> character.decreaseEnergy(10) }`. Это позволяет `UsersModule` в методе `decreaseEnergy` добавить свою логику: проверить, что энергия не уходит в минус, наложить какие-то эффекты, сохранить изменения в базу и т.д.

---
**Вопрос:** Можете ли вы привести еще один пример события, которое мог бы публиковать `UsersModule`, и какой другой модуль мог бы на него отреагировать и что-то сделать?

**Ответ пользователя:**
UserSubscribtionChanged(userId, subscribtion)

**Обратная связь:**
Прекрасный пример. Событие `UserSubscriptionChanged(userId, subscription)` очень релевантно для нашего проекта с монетизацией. На него могли бы отреагировать:
- **`MonetizationModule`**: Для корректного управления бонусами, доступом к функциям или выставлением счетов.
- **`QuestsModule`**: Если какие-то квесты доступны только подписчикам.
- **`NotificationsModule`**: Чтобы отправить пользователю уведомление о статусе его подписки.
Такой подход с событиями обеспечивает высокую гибкость и слабую связность между модулями.

---
**Вопрос:** Вспоминая все, что мы обсудили о модульном монолите, его публичных контрактах и событийной модели, можете ли вы сформулировать: какие **основные архитектурные цели** мы достигаем, выбирая именно такой подход для нашего бэкенда? То есть, почему мы делаем это так, а не просто пишем код в одном большом файле?

**Ответ пользователя:**
чёткие границы фич, контракт фичи сам себя описывает и клиенты фичи знают, что умеет фича, вместо того, чтобы лазить по всем сорцам. Возможность в верхнеуровневом модуле собирать те фичи, которые нужны, мокать, перенаправлять. отдельный релиз каждой фичи, нет привязки к общим срокам и воркфлоу. возможность иметь разную внутреннюю структуру и зависимости в каждой имплементации фичи(лучше конечно общий кодстайл и архитектура.чёткие границы фич, контракт фичи сам себя описывает и клиенты фичи знают, что умеет фича, вместо того, чтобы лазить по всем сорцам. Возможность в верхнеуровневом модуле собирать те фичи, которые нужны, мокать, перенаправлять. отдельный релиз каждой фичи, нет привязки к общим срокам и воркфлоу. возможность иметь разную внутреннюю структуру и зависимости в каждой имплементации фичи(лучше конечно общий кодстайл и архитектура. держать наружу событийные ручки делают фичи ещё менее связными, фича отдаёт наружу флоу, а кто на него подписывается - не важно. так же клиенты фичи пользуются фичей с позиции чёрного ящика.

**Обратная связь:**
Вы дали очень глубокий и точный ответ, охватывающий все ключевые аспекты. Вы совершенно верно сформулировали основные архитектурные цели, которые мы достигаем:
1.  **Четкие границы и самоописывающийся контракт:** Это снижает когнитивную нагрузку и упрощает понимание системы.
2.  **Гибкость в тестировании и разработке:** Возможность легко подменять реализации заглушками (моками).
3.  **Независимая разработка:** Хотя развертывание происходит как единое целое, разработка и тестирование могут быть независимыми.
4.  **Разнообразие внутренней структуры:** Модули могут иметь разные внутренние решения, не затрагивая внешних клиентов.
5.  **Событийная модель для слабой связности:** Паттерн Publish-Subscribe делает систему устойчивой к изменениям.
Ваш ответ показывает очень хорошее понимание принципов проектирования больших систем. Именно эти цели — **управляемая сложность**, **слабая связность**, **высокая сплоченность** и **гибкость для эволюции** — являются ключевыми причинами выбора модульного монолита.

---

**REST vs. GraphQL API paradigms**

Когда дело доходит до создания API для взаимодействия между клиентом и сервером (или даже между внутренними сервисами), две доминирующие парадигмы — это **REST (Representational State Transfer)** и **GraphQL**.

### REST

REST — это архитектурный стиль, основанный на HTTP-протоколе. Он определяет набор принципов для проектирования сетевых приложений:
*   **Ресурсы:** Все данные представлены в виде ресурсов, доступ к которым осуществляется по уникальным URL (Uniform Resource Locators). Например, `/users`, `/users/123`, `/quests`.
*   **Операции:** Для взаимодействия с ресурсами используются стандартные HTTP-методы:
    *   `GET` для получения данных.
    *   `POST` для создания новых данных.
    *   `PUT` или `PATCH` для обновления данных.
    *   `DELETE` для удаления данных.
*   **Отсутствие состояния (Stateless):** Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для обработки запроса. Сервер не должен хранить контекст клиента между запросами.
*   **Клиент-серверная архитектура:** Четкое разделение ответственности между клиентом и сервером.
*   **Кэширование:** Ответы могут быть кэшированы для повышения производительности.

**Плюсы REST:**
*   **Простота и широкая распространенность:** Легко начать, много инструментов и документации.
*   **Стандартизация:** Использует стандартные HTTP-методы и коды состояния.
*   **Кэширование:** Встроенные механизмы кэширования HTTP.

**Минусы REST:**
*   **Избыточность данных (Over-fetching):** Клиент часто получает больше данных, чем ему нужно. Например, для отображения списка пользователей может быть достаточно только имени, но API возвращает все поля пользователя.
*   **Недополучение данных (Under-fetching):** Для получения всех необходимых данных клиенту может потребоваться сделать несколько запросов. Например, получить пользователя, а затем отдельным запросом его квесты.
*   **Версионирование:** Изменение API требует версионирования (например, `/v1/users`, `/v2/users`), что усложняет поддержку.

### GraphQL

GraphQL — это язык запросов для API и среда выполнения для выполнения этих запросов на основе данных, которые вы определяете для своей службы.
*   **Единая точка входа:** Вместо множества URL, у GraphQL обычно одна конечная точка (endpoint), куда отправляются все запросы.
*   **Точный запрос данных:** Клиент запрашивает *только те данные, которые ему нужны*, и сервер отвечает *только этими данными*. Это решает проблему Over-fetching и Under-fetching.
*   **Схема:** API описывается с помощью строго типизированной схемы, которая определяет все доступные данные и операции.
*   **Операции:** Три основных типа операций:
    *   `Query` для получения данных.
    *   `Mutation` для изменения данных.
    *   `Subscription` для получения обновлений в реальном времени.

**Плюсы GraphQL:**
*   **Эффективность:** Получение только необходимых данных, минимизация количества запросов.
*   **Гибкость:** Клиент сам определяет структуру ответа.
*   **Одна конечная точка:** Упрощает управление API.
*   **Сильная типизация:** Схема GraphQL обеспечивает валидацию запросов и автодополнение.
*   **Subscriptions:** Встроенная поддержка реального времени.

**Минусы GraphQL:**
*   **Сложность кэширования:** Механизмы кэширования менее прямолинейны, чем в REST.
*   **Накладные расходы на сервер:** Разбор и валидация более сложных запросов могут требовать больше ресурсов.
*   **Более высокая кривая обучения:** Требует изучения нового языка запросов и концепций.
*   **Отсутствие стандартных кодов состояния HTTP:** Всегда возвращает 200 OK, ошибки передаются в теле ответа.

**Вопрос:** Для нашего проекта (социальной игры с геолокацией), учитывая его специфику (частое обновление состояния пользователя, получение разнообразных данных для UI, потенциальные социальные функции в реальном времени), какой API-парадигму (REST или GraphQL) вы бы предпочли для основного клиент-серверного взаимодействия и почему? Сформулируйте свое решение, учитывая как плюсы, так и минусы обеих парадигм применительно к нашему игровому контексту.