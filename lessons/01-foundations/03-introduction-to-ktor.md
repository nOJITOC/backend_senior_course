### Урок 3: Введение в Ktor

Привет! Теперь, когда у нас есть настроенное окружение, пора приступить к изучению нашего основного инструмента для бэкенда — Ktor.

**Что такое Ktor?**

Ktor — это фреймворк для создания асинхронных серверов и клиентов в Kotlin, разработанный JetBrains. Он выделяется своей легковесностью, модульностью и гибкостью, что делает его отличным выбором для создания высокопроизводительных веб-сервисов и API.

**Ключевые особенности Ktor:**

1.  **Kotlin-нативный и асинхронный:** Ktor создан специально для Kotlin и использует его корутины (coroutines) для построения неблокирующего и высокоэффективного кода. Это позволяет вашему приложению обрабатывать множество одновременных запросов с минимальными затратах ресурсов, что критично для производительности бэкенда.
2.  **Легковесный и модульный:** Ktor не является "монолитным" фреймворком. Вместо этого он предлагает набор модулей (или "фич"), которые вы подключаете по мере необходимости. Это минимизирует размер приложения и его зависимости, позволяя вам использовать только то, что действительно нужно. Например, если вам не нужна поддержка WebSockets, вы просто не подключаете соответствующий модуль.
3.  **Гибкий и непредвзятый (Unopinionated):** Ktor не навязывает вам конкретных решений для таких задач, как логирование, работа с базами данных (ORM), внедрение зависимостей (DI) или шаблонизация. Это дает вам свободу выбора библиотек, которые лучше всего подходят для вашего проекта, и позволяет легко интегрировать Ktor в существующие экосистемы.
4.  **Разработан JetBrains:** Будучи продуктом JetBrains, Ktor имеет отличную интеграцию с IntelliJ IDEA и постоянно развивается, следуя лучшим практикам Kotlin.
5.  **Высокая тестируемость:** Ktor предоставляет удобные инструменты для тестирования ваших приложений, позволяя эмулировать запросы и проверять логику без развертывания реального сервера.

Ktor идеально подходит для создания RESTful API, микросервисов, веб-сокетов и любых других сетевых приложений, где важна производительность и гибкость.

---

**Вопрос:**

Учитывая ваш опыт в Android-разработке, где Kotlin-корутины играют ключевую роль в асинхронной работе, как вы думаете, какие преимущества Ktor предлагает для бэкенд-разработки по сравнению с более традиционными или другими современными JVM-фреймворками (например, Spring Boot или Micronaut) с точки зрения разработчика, уже знакомого с Kotlin и корутинами? Какие аспекты Ktor вам кажутся наиболее привлекательными или, наоборот, могут вызвать сложности?

**Ответ:**

структурированный паралеллизм и легковесность корутин

**Обратная связь:**

Отличный ответ, вы выделили ключевые моменты. Давайте разберем их подробнее.

**Ваше наблюдение: "Структурированный параллелизм и легковесность корутин"**

Вы абсолютно правы. Это два фундаментальных преимущества, которые Ktor, как Kotlin-нативный фреймворк, наследует от корутин и превращает в мощные инструменты для бэкенда.

1.  **Структурированный параллелизм (Structured Concurrency):**
    *   **На бэкенде это критически важно.** Каждому входящему HTTP-запросу можно выделить свой `CoroutineScope`. Если в процессе обработки этого запроса запускаются дочерние задачи (например, запрос к базе данных, обращение к другому API, сложная обработка данных), они все будут привязаны к этому скоупу. Если клиент отменяет запрос (например, закрывает вкладку браузера), Ktor автоматически отменит всю цепочку дочерних корутин. Это элегантно решает проблему "подвисших" операций и утечек ресурсов, которые в традиционных моделях приходилось контролировать вручную.
    *   **Сравнение:** В Spring Boot, работа с асинхронностью часто строится на `CompletableFuture` или более сложных парадигмах, таких как Project Reactor (Flux/Mono). Хотя они мощные, они не всегда обладают такой интуитивной иерархией отмены и обработки ошибок, как структурированная конкурентность в корутинах.

2.  **Легковесность корутин:**
    *   **Масштабируемость:** Традиционная модель "один поток на запрос" очень затратна. Создание потока ОС — дорогая операция. Ktor, используя корутины, может обрабатывать тысячи одновременных запросов на небольшом пуле системных потоков. Корутина — это, по сути, легковесная задача, а не поток. Это означает, что ваше приложение может масштабироваться для обработки огромного количества подключений (что важно для нашего real-time проекта) с гораздо меньшим потреблением памяти и процессорного времени.
    *   **Сравнение:** Это прямое преимущество перед стандартной конфигурацией многих старых фреймворков. Хотя современные фреймворки, включая Spring, тоже движутся в сторону неблокирующих моделей, в Ktor это является основной, идиоматической и самой простой моделью работы, а не опцией.

**По поводу потенциальных сложностей:**

Вы не упомянули их, но я отмечу один аспект. Гибкость и "непредвзятость" (unopinionated) Ktor, которые являются его силой, могут быть и сложностью для новичков. Spring Boot предлагает готовые "стартеры" практически для всего: работы с базами данных, безопасности, логирования. В Ktor вам чаще придется самостоятельно выбирать и настраивать библиотеки для этих задач. Это требует большего понимания экосистемы, но и дает полный контроль.

Отлично, мы разобрались с "почему". Теперь давайте посмотрим на "как".

---

### Структура приложения Ktor

Давайте рассмотрим основные строительные блоки приложения на Ktor.

```kotlin
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import io.ktor.server.application.*
import io.ktor.server.response.*
import io.ktor.server.routing.*

fun main() {
    embeddedServer(Netty, port = 8080) { // 1. Серверный движок
        // 2. Модуль приложения
        routing { // 3. Плагин роутинга
            get("/") { // 4. Определение маршрута
                call.respondText("Hello, World!") // 5. Обработка запроса
            }
        }
    }.start(wait = true)
}
```

1.  **Серверный движок (`embeddedServer` и `Netty`):** Ktor может работать на разных движках. Самые популярные — Netty (по умолчанию, высокопроизводительный), Jetty и CIO (чисто Kotlin-реализация). Вы выбираете тот, который подходит под ваши задачи. `embeddedServer` — это функция, которая запускает ваше приложение.
2.  **Модуль приложения:** Лямбда-выражение `{ ... }`, которое мы передаем в `embeddedServer`, — это и есть наше приложение. Здесь мы настраиваем его логику.
3.  **Плагины (`install`):** Модульность Ktor реализуется через "Плагины" (Plugins). Это перехватчики (interceptors), которые добавляют функциональность в конвейер обработки запросов. `routing`, `CORS`, `ContentNegotiation` (для JSON), `Authentication` — всё это плагины. Вы "устанавливаете" их с помощью функции `install(PluginName)`. `routing` — настолько частый плагин, что для него есть специальный билдер `routing { ... }`.
4.  **Роутинг (`routing`):** Специальный плагин, который определяет, как приложение должно реагировать на разные URL и HTTP-методы (`GET`, `POST` и т.д.).
5.  **Обработка запроса:** Внутри блока маршрута (`get`, `post`, и т.д.) вы получаете доступ к объекту `call`, который представляет текущий HTTP-запрос. С его помощью вы можете прочитать информацию о запросе и отправить ответ (`call.respondText`, `call.respond`, `call.respondBytes` и т.д.).

---

**Вопрос:**

Концепция "Плагинов" в Ktor — ключевая. Как бы вы сравнили ее с концепцией "зависимостей" в `build.gradle.kts` в Android-проекте? В чем их принципиальное сходство и в чем фундаментальное различие их роли в приложении?

**Ответ:**

схожесть, что плагин можно внедрить в проект(install) также, как и зависимость в gradlew(implementation). различие - мы пользуемся плагинами внутри лямбды посредством DSL, плагин под капотом уже делает какую-то работу. в градл мы просто внедряем запвисимости и дальше в любом месте модуля можем их инициализировать и пользоваться

**Обратная связь:**

Отличное сравнение! Вы уловили суть и правильно разделили понятия. Давайте я немного углублю ваше наблюдение.

Вы абсолютно правы в обоих пунктах.

**Сходство:** На самом высоком уровне и то, и другое — это способ добавить в проект чужой код. `implementation` в Gradle делает код доступным на этапе компиляции, а `install` в Ktor "активирует" его в рантайме.

**Фундаментальное различие**, которое вы верно подметили, заключается в их *роли и принципе работы*:

1.  **Зависимость (Библиотека):** Это **пассивный** набор инструментов. Когда вы пишете `implementation("com.example:my-library:1.0")`, вы, по сути, кладете на полку набор "отверток и гаечных ключей". Библиотека ничего не делает сама по себе. Она просто ждет, пока *вы* в своем коде напишете `MyLibrary.doSomething()`. Вы полностью контролируете, когда и как ее использовать.

2.  **Плагин Ktor (Middleware):** Это **активный** участник жизненного цикла приложения. Когда вы пишете `install(Authentication)`, вы не просто получаете инструменты для аутентификации. Вы встраиваете в конвейер обработки запросов "охранника", который будет проверять *каждый* входящий запрос, проходящий через защищенные маршруты. Плагин сам вклинивается в процесс и выполняет свою работу, изменяя поведение всего приложения или его части.

**Аналогия:**
*   **Зависимость** — это как купить GPS-навигатор и положить его в бардачок машины. Он полезен, но заработает только тогда, когда вы его достанете, включите и введете адрес.
*   **Плагин** — это как установить в машину систему ABS. Она интегрирована в тормозную систему и автоматически срабатывает в нужный момент (при резком торможении), вам не нужно ее "вызывать" вручную.

Это понимание критически важно. В Ktor мы строим приложение, собирая его из таких "активных" блоков-плагинов, которые определяют его сквозную функциональность (роутинг, сериализация, аутентификация, логирование и т.д.).

---
### Практическое задание: Ваш первый API-эндпоинт

Сейчас ваше Ktor-приложение, созданное по шаблону, уже имеет один эндпоинт `GET /`. Наша задача — модифицировать его и добавить новый.

1.  **Откройте файл `Routing.kt`** в проекте `enjourney` (`src/main/kotlin/ru/mmteams91/Routing.kt`).
2.  **Модифицируйте существующий роут:** Измените существующий `get("/")`, чтобы он возвращал не просто текст, а осмысленное JSON-сообщение. Для этого нам понадобится плагин `ContentNegotiation` и `kotlinx.serialization`.
3.  **Добавьте новый эндпоинт:** Создайте новый `POST` эндпоинт по пути `/api/v1/quest/new`, который будет принимать в теле запроса JSON и возвращать его же в ответе.

Давайте сделаем это по шагам. Сначала настроим проект для работы с JSON.

**Шаг 1: Настройка сериализации**

Ktor требует плагин для автоматического преобразования Kotlin-объектов в JSON и обратно.

1.  **Откройте файл `Serialization.kt`** (`src/main/kotlin/ru/mmteams91/Serialization.kt`).
2.  Приведите его к следующему виду, чтобы установить плагин `ContentNegotiation` с поддержкой `kotlinx.serialization`:

```kotlin
package ru.mmteams91

import io.ktor.serialization.kotlinx.json.*
import io.ktor.server.application.*
import io.ktor.server.plugins.contentnegotiation.*
import kotlinx.serialization.json.Json

fun Application.configureSerialization() {
    install(ContentNegotiation) {
        json(Json {
            prettyPrint = true
            isLenient = true
            ignoreUnknownKeys = true
        })
    }
}
```

Этот код устанавливает плагин, который будет автоматически обрабатывать `Content-Type: application/json` для всех запросов и ответов.

**Шаг 2: Ваша задача**

Теперь ваша очередь.

1.  **Откройте файл `Routing.kt`**.
2.  Создайте `data class` с именем `StatusResponse`, у которого будет одно поле `status` типа `String`. Чтобы Ktor мог его сериализовать, пометьте класс аннотацией `@Serializable`. (Не забудьте добавить импорт `kotlinx.serialization.Serializable`).
3.  Измените существующий роут `get("/")` так, чтобы он возвращал экземпляр `StatusResponse` с сообщением "OK". Используйте `call.respond()`.
4.  Добавьте в тот же файл новый роут `post("/api/v1/quest/new")`.
5.  Внутри `post` роута, пока просто возвращайте тот же `StatusResponse("OK")`)

---
**Содержимое `Routing.kt`:**
```kotlin
package ru.mmteams91

import io.ktor.server.application.Application
import io.ktor.server.application.call
import io.ktor.server.response.respond
import io.ktor.server.response.respondText
import io.ktor.server.routing.get
import io.ktor.server.routing.post
import io.ktor.server.routing.routing
import ru.mmteams91.models.StatusResponse

fun Application.configureRouting() {
    routing {
        get("/") {
            call.respond(StatusResponse("ok"))
        }
        post("/api/v1/quest/new") {
            call.respond(StatusResponse("ok"))
        }
        get("/hello/{name}") {
            val name = call.parameters["name"]
            call.respondText("Привет, ${name ?: "незнакомец"}!")
        }
    }
}
```

**Обратная связь:**

Отлично! Вы успешно справились с заданием и даже добавили дополнительный маршрут `/hello/{name}`, что демонстрирует хорошее понимание маршрутизации в Ktor.

Вы правильно модифицировали `get("/")` и добавили `post("/api/v1/quest/new")`, возвращая `StatusResponse("ok")`. Я предполагаю, что `StatusResponse` корректно определен в файле `ru/mmteams91/models/StatusResponse.kt` и помечен аннотацией `@Serializable`, как это требуется для Ktor и `kotlinx.serialization`.

Теперь, когда `Routing.kt` выглядит правильно, давайте проверим второй файл из практического задания.

Покажите содержимое файла `enjourney/src/main/kotlin/ru/mmteams91/Serialization.kt`.

---
**Содержимое `Serialization.kt`:**
```kotlin
package ru.mmteams91

import io.ktor.serialization.kotlinx.json.json
import io.ktor.server.application.Application
import io.ktor.server.application.call
import io.ktor.server.application.install
import io.ktor.server.plugins.contentnegotiation.ContentNegotiation
import io.ktor.server.response.respond
import io.ktor.server.routing.get
import io.ktor.server.routing.routing
import kotlinx.serialization.json.Json

fun Application.configureSerialization() {
    install(ContentNegotiation) {
        json(Json {
            prettyPrint = true
            isLenient = true
            ignoreUnknownKeys = true
        })
    }
}
```

**Обратная связь:**

Отлично! Файл `Serialization.kt` настроен абсолютно верно, и вы успешно установили плагин `ContentNegotiation` с конфигурацией для `kotlinx.serialization`. Это позволит Ktor автоматически преобразовывать Kotlin-объекты в JSON и наоборот для ваших API-эндпоинтов.

Теперь, когда оба файла (`Routing.kt` и `Serialization.kt`) настроены, пришло время проверить, что все работает.

---
**Результаты проверки:**
```
http://localhost:8080/ : {
    "status": "ok"
}
http://localhost:8080/hello/YourName : Привет, YourName!
http://localhost:8080/api/v1/quest/new : {
    "status": "ok"
}
```

**Обратная связь по результатам проверки:**

Превосходно! Все эндпоинты, которые мы реализовали, работают корректно и возвращают ожидаемые результаты. Это подтверждает, что вы успешно настроили Ktor для обработки маршрутов и сериализации JSON.

Вы отлично справились с этим практическим заданием!